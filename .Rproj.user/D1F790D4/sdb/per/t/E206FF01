{
    "collab_server" : "",
    "contents" : "# http://stackoverflow.com/questions/33722757/update-handsontable-by-editing-table-and-or-eventreactive\n\n# TODO: update save & som training button\n\nshinyServer(function(input, output, session) {\n  \n  # Import data -------------------------------------------------------------\n\n  # The user can upload a data set or use the TaFeng Grocery Demo data set.\n  # All import parameters for an uploaded data set are identified atumoatically\n  # but they can also be changed manually.\n  \n  # container for reactive dataset\n  dataSet <- reactiveValues()\n  trigger <- reactiveValues()\n  trigger[['selectFeatures']] <- 0\n  \n  # switch to demo mode if \"Load Demo Data\" Button is clicked\n  observeEvent(input$loadTaFeng, {\n    dataSet[['demo']] <- 1 # demo mode: on\n    dataSet[[\"dfSummary\"]] <- NULL\n    trigger[['selectFeatures']] <- 0\n    dataInput()\n    updateButton(session ,\"som_train\", label = \" Select at least 2 features\", disabled = TRUE, style = \"danger\", icon(\"ban\"), block = TRUE)\n  })\n  \n  # switch to uploaded data mode if a data set is uploaded\n  observeEvent(input$inFile, {\n    dataSet[['demo']] <- 0 # demo mode: off\n    dataSet[[\"dfSummary\"]] <- NULL\n    trigger[['selectFeatures']] <- 0\n    dataInput()\n    updateButton(session ,\"som_train\", label = \" Select at least 2 features\", disabled = TRUE, style = \"danger\", icon(\"ban\"), block = TRUE)\n  })\n  \n  dataInput <- reactive({\n    \n    # check whether demo or uploaded data should be used\n    if(dataSet[['demo']] == 0){\n\n      # use uploaded dataset\n      if (is.null(input$inFile)){\n        # stop if no dataset is entered\n        return(NULL)\n      } else {\n        # workaround for \"auto\" | TRUE | FALSE fread() parameters\n        inFile_header <- input$inFile_header\n        if(inFile_header != \"auto\") inFile_header <- as.logical(inFile_header)\n        \n        inFile_sep <- switch(input$inFile_sep,\n                             \"Auto\"      = \"auto\",\n                             \"Comma\"     = \",\",\n                             \"Semicolon\" = \";\",\n                             \"Tab\"       = \"\\t\",\n                             \"Space\"     = \" \")\n        \n        if (input$inFile_rownames == \"TRUE\") {\n          df <- data.frame(fread(input$inFile$datapath, header=inFile_header, \n                                 sep=inFile_sep,\n                                 dec=input$inFile_dec), row.names=1)\n        } else {\n          df <- data.frame(fread(input$inFile$datapath, header=inFile_header, \n                                 sep=inFile_sep, \n                                 dec=input$inFile_dec), row.names=NULL)\n        }\n      }\n    } else {\n      # use TaFeng Grocery Demo data\n      #load(\"../../data/taFengGrocery.Rda\")\n      data(\"taFeng\")\n      df <- as.data.frame(taFeng)\n      rm(taFeng)\n    }\n    \n    # update reactive dataset (add a column for selected features)\n    dataSet[[\"dfSummary\"]] <- TBSOM::Data.Availability(df) %>% \n                            dplyr::mutate(use = FALSE) %>% \n                            dplyr::select(use,everything())\n\n    # winsorize data to shrink outliers back to normal values\n    val.numeric <- sapply(df, is.numeric)\n    df[,val.numeric] <- sapply(df[,val.numeric], winsorize)\n    \n    df\n  }) # end reactive\n    \n  # Import preview ----------------------------------------------------------\n  \n  # Preview the first 15 rows of the recently imported data for adhoc checks.\n  \n  output$preview <- renderRHandsontable({\n    if(is.null(input$inFile) & input$loadTaFeng == 0){\n      return(NULL)\n    } else {\n      DF <- dataInput() %>% filter(row_number() <= 15)\n      rhandsontable(DF, readOnly = TRUE)\n    }\n  })\n  \n  # Overview and feature selection ------------------------------------------\n  \n  # Show some summary statistics for all available features. This overview\n  # is also used for selecting the features that are used for the SOM training.\n  \n  output$overview <- renderRHandsontable({\n    if(is.null(input$inFile) & input$loadTaFeng == 0){\n      return(NULL)\n    } else {\n      trigger[['selectFeatures']] <- 1\n      DF <- dataSet[[\"dfSummary\"]]\n      rhandsontable(DF, readOnly = TRUE, selectCallback = FALSE) %>% \n        hot_col(\"use\", readOnly = FALSE) # change 'use' column to readable\n    }\n  })\n  \n  # Update selected features ------------------------------------------------\n  \n  # After (de-)selecting a feature the data set has to be updated. At least\n  # 2 features are needed for the SOM training. Therefore the \"Train SOM\" \n  # button will be disabled if there are less than 2 features selected.\n  \n  observeEvent(input$overview, { \n    if (!is.null(input$overview) & trigger[['selectFeatures']] > 0) {\n      dataSet[[\"dfSummary\"]] <- hot_to_r(input$overview)\n    }\n\n    if(sum(dataSet[[\"dfSummary\"]]$use) > 1){\n      updateButton(session ,\"som_train\", label = \" Train SOM\", disabled = FALSE, style = \"default\", icon(\"check\"), block = TRUE)\n    } else {\n      updateButton(session ,\"som_train\", label = \" Select at least 2 features\", disabled = TRUE, style = \"danger\", icon(\"ban\"), block = TRUE)\n    }\n  })\n  \n  \n  # Training SOM ------------------------------------------------------------\n  \n  # The SOM will be trained on all selected features in the overview tabset.\n  \n  # Train SOM after button is pressed\n  SOMtrained <- eventReactive(input$som_train, {\n    \n    # Reproducible\n    set.seed(input$som_seed)\n    \n    # Select only 'selected' features\n    df <- dataInput()[,dataSet[[\"dfSummary\"]]$use]\n    \n    # replacing facotrs with dummy variables\n    df <- TBSOM::RFunction_Factor2Dummies(df)\n    \n    # Normalization\n    df <- scale(df)\n    \n    # SOM training\n    som(as.matrix(df),\n        grid = somgrid(xdim = input$som_xdim, ydim = input$som_ydim, topo = input$som_topo), \n        rlen = input$som_rlen,\n        toroidal = as.logical(input$som_torodial))\n\n  })\n  \n  # SOM Evaluation Plots ----------------------------------------------------\n  \n  # Different plots will be generated which help the user to identify the\n  # quality of the created SOM.\n  \n  output$SOMtrainedFan <- renderPlot({\n    plot(SOMtrained(), type = \"codes\")\n  })\n  output$SOMtrainedChanges <- renderPlot({\n    plot(SOMtrained(), type = \"changes\")\n  })\n  output$SOMtrainedCounts <- renderPlot({\n    #plot(SOMtrained(), type = \"counts\", palette.name=coolBlueHotRed)\n    TBSOM::hexagonalPlotEval(SOMtrained(), type = \"counts\")\n  })\n  output$SOMtrainedQuality <- renderPlot({\n    #plot(SOMtrained(), type = \"quality\", palette.name=coolBlueHotRed)\n    TBSOM::hexagonalPlotEval(SOMtrained(), type = \"quality\")\n  })\n  output$SOMtrainedDist <- renderPlot({\n    #plot(SOMtrained(), type = \"dist.neighbours\", palette.name=grey.colors)\n    TBSOM::hexagonalPlotEval(SOMtrained(), type = \"dist.neighbours\")\n  })\n  \n  # Feature Heatmaps --------------------------------------------------------\n  \n  # For every selected feature a heatmap will be created to visualize the\n  # distribution over the SOM. All heatmaps will be added to a reactive\n  # gallery that automatically changes the number of plots per row depending\n  # on the screen size.\n  \n  # http://stackoverflow.com/questions/32292547/shiny-switching-between-reactive-data-sets-with-rhandsontable\n  \n  # create all heatmaps\n  observe({\n    lapply(1:length(attributes(SOMtrained()$data)$dimnames[[2]]), function(i){\n      output[[paste(\"plot\", i, sep=\"\") ]] <- renderPlot({\n        hexagonalPlotEval(SOMtrained(), type = \"heatmap\", feature = i,\n                          main=attributes(SOMtrained()$data)$dimnames[[2]][i])\n      }, height = 250, width = 250)\n    })\n  })\n  \n  # CURRENTLY ONLY IMPLIMENTED FOR THE FIRST HEATMAP\n  # create heatmaps again for zoomed view\n  observe({\n    lapply(1:length(attributes(SOMtrained()$data)$dimnames[[2]]), function(i){\n      output[[paste(\"zoomplot\", i, sep=\"\") ]] <- renderPlot({\n        hexagonalPlotEval(SOMtrained(), type = \"heatmap\", feature = i,\n                          main=attributes(SOMtrained()$data)$dimnames[[2]][i])\n        #plot(SOMtrained(), type = \"property\", property = SOMtrained()$codes[,i], \n        #     main=attributes(SOMtrained()$data)$dimnames[[2]][i], palette.name=coolBlueHotRed)\n      }, height = 450, width = 450)\n    })\n  })\n  \n  # create taglist (= gallery) of all heatmaps\n  output$SOMevalGallery <- renderUI({\n    numfigures <- length(attributes(SOMtrained()$data)$dimnames[[2]])\n    plot_output_list <- lapply(1:numfigures, function(i) {\n      plotname <- paste(\"plot\", i, sep=\"\")\n      plotclick <- paste(\"plot_click\", i, sep=\"\")\n      plotOutput(plotname, inline = TRUE, click =plotclick, brush = \"asd\")\n    })\n    \n    # Convert the list to a tagList - this is necessary for the list of items to display properly.\n    do.call(tagList, plot_output_list)\n  })\n  \n  # Open zoomed bsModal after click on plot\n  observeEvent(input$plot_click1, {\n    toggleModal(session = session , modalId = \"bsmodal1\" , toggle = \"open\")\n  })\n  \n  # TODO (DKO 13.07.2016) add observeEvent for every figure\n  \n  # Cluster SOM -------------------------------------------------------------\n  \n  # Provide the user the ability to choose between several cluster algorithms\n  # and also the number of created clusters can be adjusted. For identifying a\n  # good number of clusters there is a help plot available.\n  \n  # help plot for identifying number of cluster\n  output$som_cluster_num <- renderPlot({\n    mydata <- SOMtrained()$codes\n    wss <- (nrow(mydata)-1)*sum(apply(mydata,2,var))\n    for (i in 2:15) wss[i] <- sum(kmeans(mydata,\n                                         centers=i)$withinss)\n    plot(1:15, wss, type=\"b\", xlab=\"Number of Clusters\",\n         ylab=\"Within groups sum of squares\", main=\"Within cluster sum of squares (WCSS)\")\n  })\n  \n  # cluster SOM after button is pressed\n  SOMclustered <- eventReactive(input$som_cluster, {\n    # reset selection\n    Nodes[[\"selected\"]] <- NULL\n    Clusters[[\"selected\"]] <- NULL\n    # cluster SOM\n    if(input$cluster_type == \"ward.adjacent\"){\n      adjacentWard(SOMtrained(), toroidal = FALSE)[[input$cluster_num]]\n    } else {\n      cutree(hclust(dist(SOMtrained()$codes), method = input$cluster_type), k = input$cluster_num)\n    }\n    \n  })\n  \n  # plot clustered SOM\n  output$som_clustered <- renderPlot({\n    if(length(Clusters[[\"selected\"]]) == 0){\n      TBSOM::hexagonalPlot(SOMtrained(), values = SOMclustered(), addlegend = FALSE, segment = TRUE, colors = pretty_palette.alpha[SOMclustered()])\n      add.cluster.boundaries(SOMtrained(), SOMclustered())\n      \n      #plot(SOMtrained(), type=\"mapping\", bgcol = pretty_palette.alpha[SOMclustered()], main = \"Clusters\")\n      #add.cluster.boundaries(SOMtrained(), SOMclustered())\n    } else {\n      highlight.color <- pretty_palette.alpha\n      highlight.color[Clusters[[\"selected\"]]] <- pretty_palette[Clusters[[\"selected\"]]]\n      hexagonalPlot(SOMtrained(), values = SOMclustered(), addlegend = FALSE, segment = TRUE, colors = highlight.color[SOMclustered()])\n      #plot(SOMtrained(), type=\"mapping\", bgcol = highlight.color[SOMclustered()], main = \"Clusters\")\n      add.cluster.boundaries(SOMtrained(), SOMclustered())\n    }\n    \n  })\n  \n  # Cluster SOM Selection ---------------------------------------------------\n\n  # It is possible to select clusters with a click inside the clustered plot.\n  # These selections have to be saved in order to update the evalution plots.\n  # If you click on an already selected cluster you will deselect the cluster.\n  # All selected clusters will be highlighted.\n  \n  Clusters <- reactiveValues()\n  Nodes <- reactiveValues()\n  \n  # updated reactive values for selected clusters and nodes\n  observeEvent(input$click_SOMcluster$x,{\n    selectedNode <- nearestNode(SOMtrained(),c(input$click_SOMcluster$x,input$click_SOMcluster$y))\n    selectedCluster <- SOMclustered()[selectedNode]\n\n    # add/remove Cluster from selected Clusters\n    if(!selectedCluster %in% Clusters[[\"selected\"]]){\n      Clusters[[\"selected\"]] <- c(Clusters[[\"selected\"]],selectedCluster)\n    } else {\n      Clusters[[\"selected\"]] <- Clusters[[\"selected\"]][selectedCluster != Clusters[[\"selected\"]]]\n    }\n\n    # add/remove Node from selected Nodes\n    if(!selectedNode %in% Nodes[[\"selected\"]]){\n      Nodes[[\"selected\"]] <- c(Nodes[[\"selected\"]],selectedNode)\n    } else {\n      Nodes[[\"selected\"]] <- Nodes[[\"selected\"]][selectedNode != Nodes[[\"selected\"]]]\n    }\n  })\n  \n  # reset selection after pressing the button\n  observeEvent(input$som_cluster_reset,{\n    Nodes[[\"selected\"]] <- NULL\n    Clusters[[\"selected\"]] <- NULL\n  })\n  \n  # Cluter Evaluation -------------------------------------------------------\n  \n  # Create density plots for all chosen features grouped by the clusters. Only\n  # highlighted clusters will be plotted. Similar to the headmaps the density\n  # plots will be added to a responsive gallery.\n  # If no cluster is selected all density lines are shown.\n  \n  # create all density plots\n  observe({\n    lapply(1:length(attributes(SOMtrained()$data)$dimnames[[2]]), function(i){\n      output[[paste(\"densityPlot\", i, sep=\"\") ]] <- renderPlot({\n        df <- cbind(dataInput(),node = SOMtrained()$unit.classif,cluster = SOMclustered()[SOMtrained()$unit.classif])\n        \n        colorPalette <- pretty_palette\n        # show only density lines for \"selected\" clusters\n        if(length(Clusters[[\"selected\"]]) > 0){\n          df <- df[df$cluster %in% Clusters[[\"selected\"]], ]\n          colorPalette <- pretty_palette[sort(Clusters[[\"selected\"]])]\n        }\n        \n        ggplot(df, aes_string(attributes(SOMtrained()$data)$dimnames[[2]][i], colour = \"as.factor(cluster)\")) +\n          geom_density() +\n          theme(legend.position = \"bottom\") +\n          scale_colour_manual(name = \"clusters\", values = colorPalette)\n        \n      }, height = 250, width = 250)\n    })\n  })\n  \n  # create taglist (= gallery) of all density plots\n  output$SOMdensityGallery <- renderUI({\n    numfigures <- length(attributes(SOMtrained()$data)$dimnames[[2]])\n    plot_output_list <- lapply(1:numfigures, function(i) {\n      plotname <- paste(\"densityPlot\", i, sep=\"\")\n      plotOutput(plotname, inline = TRUE)\n    })\n\n    # Convert the list to a tagList - this is necessary for the list of items to display properly.\n    do.call(tagList, plot_output_list)\n  })\n\n  \n  # Download ----------------------------------------------------------------\n  \n  # The user will have different options to download the clustered data or\n  # some of the created plots.\n  \n  output$downall <- downloadHandler(\n    filename = function(){\n      paste(\"SOM_\",input$inFile,format(Sys.time(),\"%y-%m-%d_%H:%M:%S\"),\".zip\",sep=\"\")\n    },\n    content = function(file){\n      #profiled data\n      write.csv(dataSet[[\"dfSummary\"]],\"profiled_data.txt\", row.names = FALSE)\n      #original data\n      write.csv(dataInput(),\"dataset.csv\", row.names = FALSE)\n      #training data (kohonen class)\n      f3 <- SOMtrained()\n      saveRDS(f3,file=\"model.rds\")\n      #clusters\n      f4 <-SOMclustered() \n      saveRDS(f4,file=\"clusters.rds\")\n      \n      #pictures\n      jpeg(file = \"SOM.jpg\")\n      plot(SOMtrained())\n      dev.off()\n      jpeg(file = \"SOM_changes.jpg\")\n      plot(SOMtrained(), type = \"changes\")\n      dev.off()\n      jpeg(file = \"SOM_quality.jpg\")\n      #plot(SOMtrained(), type = \"quality\")\n      TBSOM::hexagonalPlotEval(SOMtrained(), type = \"quality\")\n      dev.off()\n      jpeg(file = \"SOM_counts.jpg\")\n      TBSOM::hexagonalPlotEval(SOMtrained(), type = \"counts\")\n      #plot(SOMtrained(), type = \"counts\")\n      dev.off()\n      jpeg(file = \"SOM_dist_neighbours.jpg\")\n      #plot(SOMtrained(), type = \"dist.neighbours\")\n      TBSOM::hexagonalPlotEval(SOMtrained(), type = \"dist.neighbours\")\n      dev.off()\n      jpeg(file = \"SOM_codes.jpg\")\n      plot(SOMtrained(), type = \"codes\")\n      dev.off()\n      \n      #clusters\n      jpeg(file = \"SOM_clusters.jpg\")\n      if(length(Clusters[[\"selected\"]]) == 0){\n        TBSOM::hexagonalPlot(SOMtrained(), values = SOMclustered(), addlegend = FALSE, segment = TRUE, colors = pretty_palette.alpha[SOMclustered()])\n        add.cluster.boundaries(SOMtrained(), SOMclustered())\n        dev.off()\n      } else {\n        highlight.color <- pretty_palette.alpha\n        highlight.color[Clusters[[\"selected\"]]] <- pretty_palette[Clusters[[\"selected\"]]]\n        TBSOM::hexagonalPlot(SOMtrained(), values = SOMclustered(), addlegend = FALSE, segment = TRUE, colors = highlight.color[SOMclustered()])\n        #plot(SOMtrained(), type=\"mapping\", bgcol = highlight.color[SOMclustered()], main = \"Clusters\")\n        add.cluster.boundaries(SOMtrained(), SOMclustered())\n        dev.off()\n      }\n      \n\n\n\n      files <- c(\"profiled_data.txt\",\"dataset.csv\",\"model.rds\",\"clusters.rds\",\n                 \"SOM.jpg\",\"SOM_changes.jpg\",\"SOM_quality.jpg\",\"SOM_counts.jpg\",\n                 \"SOM_dist_neighbours.jpg\",\"SOM_codes.jpg\",\"SOM_clusters.jpg\")\n      \n      zip(zipfile=file,files=files)\n      unlink(files)\n    }\n  )\n\n  output$downfig <- downloadHandler(\n    filename = function(){\n      paste(\"SOM_figures\",input$inFile,format(Sys.time(),\"%y-%m-%d_%H:%M:%S\"),\".zip\",sep=\"\")\n    },\n    content = function(file){\n      #pictures\n      jpeg(file = \"SOM.jpg\")\n      plot(SOMtrained())\n      dev.off()\n      jpeg(file = \"SOM_changes.jpg\")\n      plot(SOMtrained(), type = \"changes\")\n      dev.off()\n      jpeg(file = \"SOM_quality.jpg\")\n      #plot(SOMtrained(), type = \"quality\")\n      TBSOM::hexagonalPlotEval(SOMtrained(), type = \"quality\")\n      dev.off()\n      jpeg(file = \"SOM_counts.jpg\")\n      #plot(SOMtrained(), type = \"counts\")\n      TBSOM::hexagonalPlotEval(SOMtrained(), type = \"counts\")\n      dev.off()\n      jpeg(file = \"SOM_dist_neighbours.jpg\")\n      #plot(SOMtrained(), type = \"dist.neighbours\")\n      TBSOM::hexagonalPlotEval(SOMtrained(), type = \"dist.neighbours\")\n      dev.off()\n      jpeg(file = \"SOM_codes.jpg\")\n      plot(SOMtrained(), type = \"codes\")\n      dev.off()\n      \n      #clusters\n      jpeg(file = \"SOM_clusters.jpg\")\n      if(length(Clusters[[\"selected\"]]) == 0){\n        hexagonalPlot(SOMtrained(), values = SOMclustered(), addlegend = FALSE, segment = TRUE, colors = pretty_palette.alpha[SOMclustered()])\n        add.cluster.boundaries(SOMtrained(), SOMclustered())\n        dev.off()\n      } else {\n        highlight.color <- pretty_palette.alpha\n        highlight.color[Clusters[[\"selected\"]]] <- pretty_palette[Clusters[[\"selected\"]]]\n        hexagonalPlot(SOMtrained(), values = SOMclustered(), addlegend = FALSE, segment = TRUE, colors = highlight.color[SOMclustered()])\n        #plot(SOMtrained(), type=\"mapping\", bgcol = highlight.color[SOMclustered()], main = \"Clusters\")\n        add.cluster.boundaries(SOMtrained(), SOMclustered())\n        dev.off()\n      }\n      \n      \n      files <- c(\"SOM.jpg\",\"SOM_changes.jpg\",\"SOM_quality.jpg\",\"SOM_counts.jpg\",\n                 \"SOM_dist_neighbours.jpg\",\"SOM_codes.jpg\",\"SOM_clusters.jpg\")\n      \n      zip(zipfile=file,files=files)\n      unlink(files)\n    }\n  )\n  \n  output$downdata <- downloadHandler(\n    filename = function(){\n      paste(\"SOM_data\",input$inFile,format(Sys.time(),\"%y-%m-%d_%H:%M:%S\"),\".zip\",sep=\"\")\n    },\n    content = function(file){\n      #profiled data\n      write.csv(dataSet[[\"dfSummary\"]],\"profiled_data.txt\", row.names = FALSE)\n      #original data\n      write.csv(dataInput(),\"dataset.csv\", row.names = FALSE)\n      #training data (kohonen class)\n      f3 <- SOMtrained()\n      saveRDS(f3,file=\"model.rds\")\n      #clusters\n      f4 <-SOMclustered() \n      saveRDS(f4,file=\"clusters.rds\")\n\n      files <- c(\"profiled_data.txt\",\"dataset.csv\",\"model.rds\",\"clusters.rds\")\n      \n      zip(zipfile=file,files=files)\n      unlink(files)\n    }\n  )\n  \n})\n\n\n\n\n",
    "created" : 1489695523290.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1402851937",
    "id" : "E206FF01",
    "lastKnownWriteTime" : 1486675807,
    "last_content_update" : 1486675807,
    "path" : "~/projects/20170327-ABCMeeting/shiny_demo/som/inst/SOMsUI/server.R",
    "project_path" : "inst/SOMsUI/server.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}